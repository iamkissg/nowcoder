# 边输入边去重边排序, 比全部输入完毕(过程中可以去重)再排序要明显更高效, 快了近一半, 随序列增长, 效果会更明显

# 相比 old and bad version, 运行时间和内存占用都有进步
# 运行时间：30ms
# 占用内存：3556k

import sys

for line in sys.stdin:
    N = int(line.strip())
    L = [0]  # v >= 1, 0 作为第一个元素, 作为左边边界
    for i in range(N):
        v = int(input())
        if v in L:
            continue

        p, n = 0, len(L)-1  # 首尾元素的索引
        if L[p] > v:
            n = 0
        elif L[n] < v:
            n = n+1
        else:
            # 循环结束的时候, n 停留在正好大于 v 的位置上
            while p + 1 < n:
                c = (p+n) // 2
                if L[c] < v:
                    p = c
                else:
                    n = c
        L = L[:n] + [v] + L[n:]

    for l in L[1:]:
        print(l)


# testcase:
# 61
# 25
# 29
# 105
# 52
# 108
# 73
# 58
# 38
# 64
# 14
# 55
# 98
# 94
# 102
# 35
# 60
# 68
# 15
# 27
# 103
# 73
# 55
# 35
# 33
# 47
# 35
# 16
# 31
# 108
# 46
# 65
# 89
# 13
# 51
# 51
# 99
# 113
# 66
# 111
# 99
# 64
# 54
# 117
# 20
# 14
# 106
# 9
# 29
# 11
# 25
# 100
# 58
# 79
# 69
# 84
# 106
# 59
# 92
# 42
# 11
# 92

